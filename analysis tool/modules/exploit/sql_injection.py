import re
import glob
import os
import json

class SQLI:
    UNSAFE_SQL_FUNCTIONS = ["execute", "$wpdb->query", "$wpdb->get_results", "$this->db", "esc_sql", "eval", "exec"]
    SAFE_SQL_FUNCTIONS = ["prepare", "prepareStatement", "$wpdb->prepare"]
    USER_INPUTS = ["$_GET", "$_POST", "$_REQUEST", "$_SERVER", "$_COOKIE", "$_SESSION", "$_GLOBALS", "$sql", "$query", "$user_input", "$input"]

    SQL_PATTERN = re.compile(
        r"(SELECT|INSERT|UPDATE|DELETE|REPLACE|ALTER|DROP|CREATE|FROM|INTO|TABLE|DATABASE).*?['\"]?\$[_A-Za-z0-9]+['\"]?",
        re.IGNORECASE
    )

    CONCATENATION_PATTERN = re.compile(r"(\$[_A-Za-z0-9]+\s*\.\s*['\"].*['\"]?)")

    DANGEROUS_KEYWORDS = re.compile(
        r"(UNION.*SELECT|INFORMATION_SCHEMA|LOAD_FILE|OUTFILE|DUMPFILE|EXEC|EXECUTE|SLEEP\s*\(|BENCHMARK\s*\(|XP_CMD|CAST\s*\(|CONCAT\s*\(|OR\s+1=1|AND\s+1=1)",
        re.IGNORECASE
    )

    def __init__(self, plugin_path, result_dir):
        self.plugin_path = plugin_path
        self.result_dir = result_dir
        os.makedirs(result_dir, exist_ok=True)

    def analyze_file(self, file_path):
        print(f"검사 중인 파일: {file_path}")
        with open(file_path, 'r', encoding='utf-8') as file:
            php_code = file.read()
        return self.analyze_code(php_code, file_path)

    def analyze_directory(self):
        vulnerabilities = []
        php_files = glob.glob(os.path.join(self.plugin_path, '**/*.php'), recursive=True)
        for php_file in php_files:
            vulnerabilities.extend(self.analyze_file(php_file))

        # JSON 파일로 저장
        result_file = os.path.join(self.result_dir, "results.json")
        with open(result_file, "w", encoding="utf-8") as f:
            json.dump(vulnerabilities, f, ensure_ascii=False, indent=4)

        if vulnerabilities:
            print(f"[+] SQLI 취약점 발견! 결과 저장: {result_file}")
        else:
            print("[-] SQLI 취약점이 발견되지 않음.")

    def analyze_code(self, php_code, file_path):
        vulnerabilities = []
        lines = php_code.split("\n")
        multi_line_sql = ""
        multi_line_start = None

        for line_no, line in enumerate(lines, start=1):
            stripped_line = line.strip()

            # 주석 제외
            if stripped_line.startswith("//") or stripped_line.startswith("#") or stripped_line.startswith("/*") or stripped_line.startswith("*"):
                continue

            # 다중 라인 SQL 문 처리
            if multi_line_start:
                multi_line_sql += " " + stripped_line
                if stripped_line.endswith(";"):
                    vulnerabilities.extend(self.check_vulnerability(multi_line_sql, multi_line_start, file_path))
                    multi_line_sql = ""
                    multi_line_start = None
                continue

            # 안전한 SQL 실행 구문 제외
            if any(func in stripped_line for func in self.SAFE_SQL_FUNCTIONS):
                continue

            # 위험한 SQL 함수 포함 여부 확인
            if any(func in stripped_line for func in self.UNSAFE_SQL_FUNCTIONS):
                vulnerabilities.extend(self.check_vulnerability(stripped_line, line_no, file_path))

                # SQL 구문이 여러 줄에 걸쳐 있을 경우 처리
                if not stripped_line.endswith(";"):
                    multi_line_sql = stripped_line
                    multi_line_start = line_no

        return vulnerabilities

    def check_vulnerability(self, line, line_no, file_path):
        vulnerabilities = []

        # 사용자 입력이 직접 포함된 경우 감지
        if any(user_input in line for user_input in self.USER_INPUTS):
            if self.CONCATENATION_PATTERN.search(line) or self.SQL_PATTERN.search(line):
                vulnerabilities.append({
                    "file": file_path,
                    "line": line_no,
                    "code": line.strip(),
                    "type": "사용자 입력이 포함된 SQL 실행 감지"
                })

            # 추가적인 SQL Injection 공격 기법 감지
            if self.DANGEROUS_KEYWORDS.search(line):
                vulnerabilities.append({
                    "file": file_path,
                    "line": line_no,
                    "code": line.strip(),
                    "type": "SQL 인젝션 공격 기법 포함 가능성"
                })

        return vulnerabilities
